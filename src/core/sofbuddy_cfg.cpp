#include "sofbuddy_cfg.h"

#include "sof_compat.h"
#include "util.h"

#include <windows.h>

#include <algorithm>
#include <cstdio>
#include <string>
#include <utility>
#include <vector>

namespace {

constexpr const char* kCfgRelativePath = "/base/sofbuddy.cfg";

using CvarSnapshot = std::vector<std::pair<std::string, std::string>>;

bool g_cfg_exec_queued = false;

void strip_trailing_slashes(std::string& path) {
    while (path.size() > 1 && (path.back() == '/' || path.back() == '\\')) {
        path.pop_back();
    }
}

std::string normalized_basedir() {
    std::string base = ".";
    cvar_t* basedir = findCvar(const_cast<char*>("basedir"));
    if (basedir && basedir->string && basedir->string[0]) {
        base = basedir->string;
    }
    strip_trailing_slashes(base);
    if (base.empty()) {
        base = ".";
    }
    return base;
}

std::string sofbuddy_cfg_path() {
    std::string base = normalized_basedir();
    return base + kCfgRelativePath;
}

void ensure_base_dir_exists() {
    std::string base = normalized_basedir();
    std::string base_dir = base + "/base";

    if (CreateDirectoryA(base_dir.c_str(), nullptr)) {
        return;
    }

    const DWORD err = GetLastError();
    if (err != ERROR_ALREADY_EXISTS) {
        PrintOut(PRINT_BAD, "sofbuddy_cfg: failed to create %s (error=%lu)\n",
                 base_dir.c_str(), static_cast<unsigned long>(err));
    }
}

cvar_t* get_cvar_head() {
    void* list_addr = rvaToAbsExe((void*)0x0024B1D8);
    if (!list_addr) {
        return nullptr;
    }
    return *reinterpret_cast<cvar_t**>(list_addr);
}

bool should_persist_cvar(const cvar_t* cvar) {
    if (!cvar || !cvar->name || !cvar->name[0]) {
        return false;
    }
    return (cvar->flags & CVAR_SOFBUDDY_ARCHIVE) != 0;
}

std::string escape_cfg_value(const char* value) {
    std::string escaped;
    if (!value) {
        return escaped;
    }
    for (const char* p = value; *p; ++p) {
        const char ch = *p;
        if (ch == '\\' || ch == '"') {
            escaped.push_back('\\');
        }
        escaped.push_back(ch);
    }
    return escaped;
}

CvarSnapshot capture_snapshot() {
    CvarSnapshot snapshot;
    for (cvar_t* var = get_cvar_head(); var; var = var->next) {
        if (!should_persist_cvar(var)) {
            continue;
        }
        const char* value = var->string ? var->string : "";
        snapshot.emplace_back(var->name, value);
    }

    std::sort(snapshot.begin(), snapshot.end(),
              [](const std::pair<std::string, std::string>& a,
                 const std::pair<std::string, std::string>& b) {
                  return a.first < b.first;
              });
    return snapshot;
}

bool write_snapshot_to_disk(const CvarSnapshot& snapshot) {
    ensure_base_dir_exists();
    const std::string path = sofbuddy_cfg_path();

    FILE* f = std::fopen(path.c_str(), "wb");
    if (!f) {
        PrintOut(PRINT_BAD, "sofbuddy_cfg: failed to open %s for write\n", path.c_str());
        return false;
    }

    std::fprintf(f, "// Auto-generated by sof_buddy.\n");
    std::fprintf(f, "// Loaded automatically at startup.\n\n");

    for (const auto& entry : snapshot) {
        const std::string escaped = escape_cfg_value(entry.second.c_str());
        std::fprintf(f, "set %s \"%s\"\n", entry.first.c_str(), escaped.c_str());
    }

    std::fclose(f);
    return true;
}

} // namespace

void sofbuddy_cfg_exec_startup(void) {
    if (g_cfg_exec_queued) {
        return;
    }
    g_cfg_exec_queued = true;

    if (!orig_Cmd_ExecuteString) {
        PrintOut(PRINT_BAD, "sofbuddy_cfg: Cmd_ExecuteString not available for startup exec\n");
        return;
    }

    // Resolve through FS search path. We write to {basedir}/base/sofbuddy.cfg.
    orig_Cmd_ExecuteString("exec sofbuddy.cfg\n");
}

void sofbuddy_cfg_save_now(void) {
    const CvarSnapshot snapshot = capture_snapshot();
    write_snapshot_to_disk(snapshot);
}

void sofbuddy_cfg_cl_shutdown_post_callback(void) {
    sofbuddy_cfg_save_now();
}
